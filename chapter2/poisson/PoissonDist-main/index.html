<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>泊松分布期望演示：光子探测实验室</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f2f5;
            /* Ambient Light Background - Intensified for Glass Effect */
            background-image: 
                radial-gradient(at 0% 0%, rgba(59, 130, 246, 0.3) 0px, transparent 50%),
                radial-gradient(at 100% 0%, rgba(249, 115, 22, 0.25) 0px, transparent 50%),
                radial-gradient(at 100% 100%, rgba(167, 139, 250, 0.3) 0px, transparent 50%),
                radial-gradient(at 0% 100%, rgba(59, 130, 246, 0.2) 0px, transparent 50%),
                radial-gradient(at 50% 50%, rgba(255, 255, 255, 0.4) 0px, transparent 50%);
            background-attachment: fixed;
            color: #1f2937;
            overflow-x: hidden;
        }

        .font-mono-tech {
            font-family: 'JetBrains Mono', monospace;
        }

        /* Canvas styling - Transparent to show glass behind */
        #particleCanvas, #chartCanvas {
            background: transparent; 
            border-radius: 0.5rem;
        }

        /* Custom Range Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 24px;
            width: 24px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.95);
            cursor: pointer;
            margin-top: -10px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.15), inset 0 0 0 6px #3b82f6; /* Halo style */
            border: 2px solid rgba(255,255,255,0.8);
            backdrop-filter: blur(4px);
            transition: transform 0.1s, box-shadow 0.1s;
        }

        input[type=range]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 10px rgba(37, 99, 235, 0.3), inset 0 0 0 6px #2563eb;
        }

        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: rgba(209, 213, 219, 0.5);
            border-radius: 2px;
        }

        /* ULTRA GLASSMORPHISM */
        .glass-card {
            background: rgba(255, 255, 255, 0.45); /* High transparency */
            backdrop-filter: blur(25px) saturate(180%); /* Strong blur + saturation pop */
            -webkit-backdrop-filter: blur(25px) saturate(180%);
            box-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.5); /* Thinner, crisper border */
            border-top: 1px solid rgba(255, 255, 255, 0.8);
            border-left: 1px solid rgba(255, 255, 255, 0.8);
        }

        .stat-card {
            background: rgba(255, 255, 255, 0.35);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.4);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.05);
        }
        
        .inner-shadow {
            box-shadow: inset 0 2px 4px 0 rgba(0, 0, 0, 0.03);
            background: rgba(249, 250, 251, 0.4);
        }

        .btn-primary {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            box-shadow: 0 4px 12px rgba(37, 99, 235, 0.25);
        }
        .btn-primary:hover {
            background: linear-gradient(135deg, #2563eb 0%, #1d4ed8 100%);
            transform: translateY(-1px);
            box-shadow: 0 6px 16px rgba(37, 99, 235, 0.35);
        }
        .btn-secondary {
            background: rgba(255, 255, 255, 0.5);
            color: #374151;
            border: 1px solid rgba(255, 255, 255, 0.6);
            backdrop-filter: blur(10px);
        }
        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.8);
            border-color: #9ca3af;
        }

        .grid-pattern {
            background-image: linear-gradient(#9ca3af 1px, transparent 1px), linear-gradient(90deg, #9ca3af 1px, transparent 1px);
            background-size: 24px 24px;
            opacity: 0.15;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 md:p-8 gap-6">

    <!-- Header -->
    <header class="w-full max-w-6xl flex flex-col md:flex-row justify-between items-start md:items-center mb-2">
        <div>
            <h1 class="text-3xl md:text-4xl font-bold text-gray-900 tracking-tight">
                <span class="text-blue-600">POISSON</span> OPTICS
            </h1>
            <p class="text-gray-500 font-medium mt-1">泊松分布期望演示工具</p>
        </div>
        <div class="mt-4 md:mt-0 flex gap-4 text-xs font-mono-tech text-gray-400">
            <div class="flex items-center gap-2">
                <div class="w-2 h-2 rounded-full bg-green-500 animate-pulse"></div>
                <span>SYSTEM READY</span>
            </div>
            <div>VER 2.0.1 / LIGHT MODE</div>
        </div>
    </header>

    <!-- Main Content Grid -->
    <main class="w-full max-w-6xl grid grid-cols-1 lg:grid-cols-12 gap-8">
        
        <!-- Left Column: Visualization & Controls -->
        <div class="lg:col-span-7 flex flex-col gap-6">
            
            <!-- Particle View Container -->
            <div class="relative w-full aspect-video glass-card rounded-2xl overflow-hidden border border-white/50">
                <!-- Grid Background -->
                <div class="absolute inset-0 grid-pattern opacity-50"></div>
                
                <canvas id="particleCanvas" class="w-full h-full block relative z-10"></canvas>
                
                <div class="absolute top-4 left-4 font-mono-tech text-xs text-blue-600 bg-blue-50 px-3 py-1.5 rounded-full border border-blue-100 z-20 shadow-sm">
                    SENSOR FEED
                </div>
                <div id="flashOverlay" class="absolute inset-0 bg-blue-500 mix-blend-overlay pointer-events-none opacity-0 transition-opacity duration-200 z-30"></div>
            </div>

            <!-- Controls Panel -->
            <div class="glass-card p-6 rounded-2xl">
                <div class="flex flex-col gap-6">
                    <!-- Lambda Slider -->
                    <div>
                        <div class="flex justify-between items-end mb-4">
                            <label class="text-gray-700 font-bold flex items-center gap-2">
                                <span class="bg-blue-100 text-blue-700 px-2 py-0.5 rounded text-sm font-mono-tech">λ</span> 
                                光源强度 (期望值)
                            </label>
                            <span id="lambdaValue" class="font-mono-tech text-3xl text-blue-600 font-bold">5.0</span>
                        </div>
                        <div class="relative h-6 flex items-center">
                            <input type="range" id="lambdaSlider" min="1" max="15" step="0.1" value="5">
                        </div>
                        <div class="flex justify-between text-xs text-gray-400 mt-2 font-mono-tech">
                            <span>WEAK (1.0)</span>
                            <span>STRONG (15.0)</span>
                        </div>
                        <p class="text-xs text-gray-500 mt-3 leading-relaxed">
                            调整每秒到达传感器的<strong>平均光子数</strong>。由于量子随机性，实际每次探测到的数量会在这个数值附近波动。
                        </p>
                    </div>

                    <!-- Speed Control -->
                    <div class="bg-gray-50 p-3 rounded-xl border border-gray-200">
                        <label class="text-xs font-bold text-gray-500 uppercase block mb-2">模拟速度</label>
                        <div class="flex bg-white rounded-lg p-1 border border-gray-200 shadow-sm">
                            <button id="speedSlow" class="flex-1 py-1 text-xs font-bold rounded text-gray-500 hover:bg-gray-100 transition-colors">慢</button>
                            <button id="speedNormal" class="flex-1 py-1 text-xs font-bold rounded bg-blue-100 text-blue-700 shadow-sm">中</button>
                            <button id="speedFast" class="flex-1 py-1 text-xs font-bold rounded text-gray-500 hover:bg-gray-100 transition-colors">快</button>
                        </div>
                    </div>

                    <hr class="border-gray-200">

                    <!-- Buttons -->
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
                        <button id="btnSingle" class="btn-primary text-white font-semibold py-3 px-4 rounded-xl transition-all active:scale-95 shadow-blue-200">
                            发射单次脉冲
                        </button>
                        <button id="btnAuto" class="btn-secondary font-semibold py-3 px-4 rounded-xl transition-all active:scale-95">
                            自动连续实验
                        </button>
                        <button id="btnReset" class="text-red-500 hover:text-red-700 hover:bg-red-50 font-medium py-3 px-4 rounded-xl transition-colors text-sm">
                            重置数据
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Right Column: Statistics & Theory -->
        <div class="lg:col-span-5 flex flex-col gap-6">
            
            <!-- Stats Display -->
            <div class="grid grid-cols-2 gap-4">
                <!-- Current Count Card -->
                <div class="stat-card p-5 rounded-2xl flex flex-col items-center justify-center text-center relative overflow-hidden group">
                    <div class="absolute top-0 right-0 w-16 h-16 bg-blue-50 rounded-bl-full -mr-4 -mt-4 transition-transform group-hover:scale-110"></div>
                    <span class="text-gray-400 text-[10px] uppercase font-bold tracking-widest mb-2 z-10">本次探测光子数</span>
                    <span id="currentCount" class="text-5xl font-mono-tech text-gray-800 font-bold z-10 transition-all">-</span>
                </div>

                <!-- Total Exp Card -->
                <div class="stat-card p-5 rounded-2xl flex flex-col items-center justify-center text-center">
                    <span class="text-gray-400 text-[10px] uppercase font-bold tracking-widest mb-2">实验总次数</span>
                    <span id="totalExperiments" class="text-4xl font-mono-tech text-blue-600 font-bold">0</span>
                </div>

                <!-- Comparison Card -->
                <div class="glass-card p-5 rounded-2xl col-span-2 border border-white/60 shadow-lg">
                     <div class="flex justify-between items-center mb-4">
                         <h3 class="text-xs font-bold text-gray-400 uppercase tracking-wider">数据校准中心</h3>
                         <div class="flex gap-2">
                             <div class="px-2 py-0.5 bg-blue-50 text-blue-600 text-[10px] font-bold rounded border border-blue-100">THEORY</div>
                             <div class="px-2 py-0.5 bg-orange-50 text-orange-600 text-[10px] font-bold rounded border border-orange-100">EXP</div>
                         </div>
                     </div>

                     <div class="grid grid-cols-2 gap-4 mb-4">
                        <div class="bg-white/50 rounded-xl p-3 border border-gray-100 flex flex-col items-center relative overflow-hidden">
                            <span class="text-[10px] text-gray-400 uppercase font-bold mb-1">期望值 Expectation</span>
                            <div class="flex items-baseline gap-2">
                                <span id="theoreticalMean" class="text-xl font-mono-tech text-blue-500 font-bold">5.00</span>
                                <span class="text-[10px] text-gray-300">vs</span>
                                <span id="experimentalMean" class="text-xl font-mono-tech text-orange-500 font-bold">0.00</span>
                            </div>
                            <div class="w-full h-0.5 bg-gray-100 mt-2"></div>
                        </div>
                        <div class="bg-white/50 rounded-xl p-3 border border-gray-100 flex flex-col items-center relative overflow-hidden">
                            <span class="text-[10px] text-gray-400 uppercase font-bold mb-1">标准差 Deviation</span>
                            <div class="flex items-baseline gap-2">
                                <span id="theoreticalSD" class="text-xl font-mono-tech text-blue-500/80 font-bold">2.24</span>
                                <span class="text-[10px] text-gray-300">vs</span>
                                <span id="experimentalSD" class="text-xl font-mono-tech text-orange-500/80 font-bold">0.00</span>
                            </div>
                            <div class="w-full h-0.5 bg-gray-100 mt-2"></div>
                        </div>
                     </div>
                     
                     <!-- Deviation Meter -->
                     <div class="relative pt-4 pb-2 px-2 bg-gray-50/80 rounded-xl border border-gray-200/50 inner-shadow">
                        <div class="absolute top-1.5 left-0 w-full text-center text-[9px] text-gray-400 font-bold tracking-widest">均值偏差校准</div>
                        
                        <!-- Scale Marks -->
                        <div class="flex justify-between px-1 mb-1 text-[8px] text-gray-300 font-mono-tech select-none">
                            <span>-2.0</span><span>-1.0</span><span class="text-gray-400">0</span><span>+1.0</span><span>+2.0</span>
                        </div>

                        <!-- The Track -->
                        <div class="w-full bg-gray-200 h-2.5 rounded-full overflow-hidden relative shadow-inner">
                            <!-- Center Line -->
                            <div class="absolute top-0 left-1/2 w-px h-full bg-gray-400 z-10"></div>
                            <!-- Grid lines -->
                            <div class="absolute inset-0 w-full h-full grid-pattern opacity-30"></div>
                            
                            <div id="diffBar" class="absolute top-0 h-full bg-green-500 transition-all duration-300 rounded-full shadow-sm" style="left: 50%; width: 0px;"></div>
                        </div>
                     </div>
                </div>
            </div>

            <!-- Histogram -->
            <div class="glass-card p-4 rounded-2xl flex flex-col">
                <div class="flex flex-col sm:flex-row justify-between items-start sm:items-center mb-3 px-2 gap-2">
                    <div class="flex items-center gap-3">
                        <h3 class="text-xs font-bold text-gray-400 uppercase tracking-wider">分布直方图</h3>
                        <!-- Sigma Toggles -->
                        <div class="flex bg-gray-100 rounded-lg p-0.5">
                            <button id="btnSigma1" class="px-2 py-0.5 text-[10px] font-bold rounded-md bg-white shadow-sm text-blue-600 transition-all">1σ (68%)</button>
                            <button id="btnSigma2" class="px-2 py-0.5 text-[10px] font-bold rounded-md text-gray-400 hover:text-gray-600 transition-all">2σ (95%)</button>
                            <button id="btnSigma3" class="px-2 py-0.5 text-[10px] font-bold rounded-md text-gray-400 hover:text-gray-600 transition-all">3σ (99%)</button>
                        </div>
                    </div>
                    
                    <div class="flex gap-3">
                        <div class="flex items-center gap-1.5">
                            <div class="w-2.5 h-2.5 bg-blue-400 rounded-sm"></div>
                            <span class="text-[10px] text-gray-500 font-medium">实验</span>
                        </div>
                        <div class="flex items-center gap-1.5">
                            <div class="w-2.5 h-2.5 bg-orange-400 rounded-full"></div>
                            <span class="text-[10px] text-gray-500 font-medium">理论</span>
                        </div>
                        <div class="flex items-center gap-1.5">
                            <div class="w-2.5 h-2.5 bg-orange-100 border border-orange-300 rounded-sm"></div>
                            <span id="legendSigmaText" class="text-[10px] text-gray-500 font-medium">置信区间</span>
                        </div>
                    </div>
                </div>
                <div class="relative w-full h-48">
                    <canvas id="chartCanvas" class="w-full h-full block"></canvas>
                </div>
            </div>

            <!-- Explanation -->
            <div class="p-5 bg-blue-50/80 backdrop-blur-sm rounded-2xl border border-blue-100/50 text-sm text-blue-900 leading-relaxed shadow-sm">
                <div class="flex items-center gap-2 mb-2">
                    <svg class="w-4 h-4 text-blue-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>
                    <h3 class="font-bold text-blue-700">核心概念</h3>
                </div>
                <p class="mb-2 text-blue-800/80">
                    <strong class="text-blue-900">泊松分布</strong> 描述了在固定时间间隔内，稀有事件（如光子到达）发生的次数概率。
                </p>
                <p class="text-blue-800/80">
                    虽然我们设定了平均强度 <strong class="text-blue-700 font-mono-tech">λ</strong>，但单次实验的结果 <strong class="text-blue-900 font-mono-tech">k</strong> 是随机的。只有通过大量的重复实验，平均值才会逐渐收敛于 <strong class="text-blue-700 font-mono-tech">λ</strong>。
                </p>
                <p class="mt-2 text-blue-800/80">
                    <strong class="text-blue-900">波动性 (Standard Deviation)</strong>：对于泊松分布，标准差 <span class="font-mono-tech bg-blue-100 px-1 rounded text-blue-700">σ = √λ</span>。这意味着期望值越大，数据的绝对波动范围越大（图表中橙色阴影区域）。
                </p>
            </div>
        </div>
    </main>

    <script>
        // --- Configuration & State ---
        const state = {
            lambda: 5.0,
            experiments: [], // array of counts
            isAutoRunning: false,
            autoRunInterval: null,
            maxHistory: 2000,
            simulationSpeed: 100, // ms
            sigmaMultiplier: 1
        };

        // --- DOM Elements ---
        const els = {
            particleCanvas: document.getElementById('particleCanvas'),
            chartCanvas: document.getElementById('chartCanvas'),
            lambdaSlider: document.getElementById('lambdaSlider'),
            lambdaValue: document.getElementById('lambdaValue'),
            btnSingle: document.getElementById('btnSingle'),
            btnAuto: document.getElementById('btnAuto'),
            btnReset: document.getElementById('btnReset'),
            currentCount: document.getElementById('currentCount'),
            totalExperiments: document.getElementById('totalExperiments'),
            theoreticalMean: document.getElementById('theoreticalMean'),
            experimentalMean: document.getElementById('experimentalMean'),
            flashOverlay: document.getElementById('flashOverlay'),
            diffBar: document.getElementById('diffBar'),
            theoreticalSD: document.getElementById('theoreticalSD'),
            experimentalSD: document.getElementById('experimentalSD'),
            speedSlow: document.getElementById('speedSlow'),
            speedNormal: document.getElementById('speedNormal'),
            speedFast: document.getElementById('speedFast'),
            btnSigma1: document.getElementById('btnSigma1'),
            btnSigma2: document.getElementById('btnSigma2'),
            btnSigma3: document.getElementById('btnSigma3'),
            legendSigmaText: document.getElementById('legendSigmaText')
        };

        // --- Canvas Setup ---
        const pCtx = els.particleCanvas.getContext('2d');
        const cCtx = els.chartCanvas.getContext('2d');

        function resizeCanvas() {
            // Get display size
            const pRect = els.particleCanvas.getBoundingClientRect();
            const cRect = els.chartCanvas.getBoundingClientRect();

            // Set actual size in memory (scaled to account for pixel density if needed, keeping 1:1 for simplicity here)
            els.particleCanvas.width = pRect.width;
            els.particleCanvas.height = pRect.height;
            els.chartCanvas.width = cRect.width;
            els.chartCanvas.height = cRect.height;
            
            drawChart();
        }
        window.addEventListener('resize', resizeCanvas);
        // Initial size check needs a slight delay to ensure layout is computed
        setTimeout(resizeCanvas, 50);

        // --- Math Functions ---
        
        function getPoissonRandom(lambda) {
            const L = Math.exp(-lambda);
            let k = 0;
            let p = 1;
            do {
                k++;
                p *= Math.random();
            } while (p > L);
            return k - 1;
        }

        function poissonPMF(k, lambda) {
            let factorial = 1;
            for (let i = 1; i <= k; i++) factorial *= i;
            return (Math.pow(lambda, k) * Math.exp(-lambda)) / factorial;
        }

        // --- Particle System (Optimized with Heat Map) ---
        let particles = [];
        let ripples = [];
        
        // Heat map canvas for persistent impact marks (much more performant)
        let heatCanvas = null;
        let heatCtx = null;
        const HEAT_DECAY = 0.997; // Slow decay rate per frame
        const MAX_HEAT = 255;
        
        function initHeatMap() {
            heatCanvas = document.createElement('canvas');
            heatCanvas.width = els.particleCanvas.width;
            heatCanvas.height = els.particleCanvas.height;
            heatCtx = heatCanvas.getContext('2d', { willReadFrequently: true });
            heatCtx.fillStyle = 'rgba(0,0,0,0)';
            heatCtx.fillRect(0, 0, heatCanvas.width, heatCanvas.height);
        }
        
        function resizeHeatMap() {
            if (!heatCanvas) {
                initHeatMap();
                return;
            }
            // Preserve existing heat data when resizing
            const oldData = heatCtx.getImageData(0, 0, heatCanvas.width, heatCanvas.height);
            heatCanvas.width = els.particleCanvas.width;
            heatCanvas.height = els.particleCanvas.height;
            heatCtx.putImageData(oldData, 0, 0);
        }
        
        // Add heat at impact point with gaussian-like spread
        function addHeat(x, y, intensity = 30) {
            if (!heatCtx) return;
            
            const radius = 6 + Math.random() * 4;
            const gradient = heatCtx.createRadialGradient(x, y, 0, x, y, radius);
            
            // Add to existing heat (use lighter blend mode)
            heatCtx.globalCompositeOperation = 'lighter';
            gradient.addColorStop(0, `rgba(255, 255, 255, ${intensity / 255})`);
            gradient.addColorStop(0.4, `rgba(200, 200, 255, ${intensity / 400})`);
            gradient.addColorStop(1, 'rgba(100, 150, 255, 0)');
            
            heatCtx.fillStyle = gradient;
            heatCtx.beginPath();
            heatCtx.arc(x, y, radius, 0, Math.PI * 2);
            heatCtx.fill();
            
            heatCtx.globalCompositeOperation = 'source-over';
        }
        
        // Apply decay to heat map
        function decayHeatMap() {
            if (!heatCtx || !heatCanvas.width || !heatCanvas.height) return;
            
            // Subtle fade effect
            heatCtx.globalCompositeOperation = 'source-over';
            heatCtx.fillStyle = 'rgba(0, 0, 0, 0.008)';
            heatCtx.fillRect(0, 0, heatCanvas.width, heatCanvas.height);
        }
        
        // Convert heat intensity to color (cool blue -> warm magenta -> white hot)
        function drawHeatMap(ctx) {
            if (!heatCanvas || !heatCtx) return;
            
            const w = heatCanvas.width;
            const h = heatCanvas.height;
            if (w === 0 || h === 0) return;
            
            const heatData = heatCtx.getImageData(0, 0, w, h);
            const outputData = ctx.createImageData(w, h);
            
            for (let i = 0; i < heatData.data.length; i += 4) {
                // Use the white channel as heat intensity
                const heat = heatData.data[i]; // R channel
                
                if (heat > 2) {
                    // Color mapping based on heat intensity
                    // Low: Cyan/Blue -> Mid: Blue/Purple -> High: Magenta/Pink -> Max: White
                    let r, g, b, a;
                    
                    if (heat < 50) {
                        // Cold: Cyan-Blue
                        const t = heat / 50;
                        r = Math.floor(30 * t);
                        g = Math.floor(150 + 50 * t);
                        b = Math.floor(200 + 55 * t);
                        a = Math.floor(80 + heat * 2);
                    } else if (heat < 120) {
                        // Warm: Blue -> Purple
                        const t = (heat - 50) / 70;
                        r = Math.floor(30 + 130 * t);
                        g = Math.floor(200 - 100 * t);
                        b = 255;
                        a = Math.floor(180 + heat * 0.5);
                    } else if (heat < 200) {
                        // Hot: Purple -> Magenta/Pink
                        const t = (heat - 120) / 80;
                        r = Math.floor(160 + 80 * t);
                        g = Math.floor(100 - 50 * t + 100 * t);
                        b = Math.floor(255 - 30 * t);
                        a = Math.floor(220 + heat * 0.15);
                    } else {
                        // White hot
                        const t = (heat - 200) / 55;
                        r = Math.floor(240 + 15 * t);
                        g = Math.floor(150 + 105 * t);
                        b = Math.floor(225 + 30 * t);
                        a = 255;
                    }
                    
                    outputData.data[i] = r;
                    outputData.data[i + 1] = g;
                    outputData.data[i + 2] = b;
                    outputData.data[i + 3] = a;
                }
            }
            
            ctx.putImageData(outputData, 0, 0);
        }
        
        function clearHeatMap() {
            if (heatCtx && heatCanvas) {
                heatCtx.clearRect(0, 0, heatCanvas.width, heatCanvas.height);
            }
        }

        class Particle {
            constructor(targetX, targetY) {
                const angle = Math.random() * Math.PI * 2;
                const dist = Math.max(els.particleCanvas.width, els.particleCanvas.height) * 0.6;
                
                this.x = els.particleCanvas.width / 2 + Math.cos(angle) * dist;
                this.y = els.particleCanvas.height / 2 + Math.sin(angle) * dist;
                this.targetX = targetX;
                this.targetY = targetY;
                
                this.life = 1.0;
                this.arrived = false;
                const hue = 200 + Math.random() * 50; 
                this.color = `hsla(${hue}, 90%, 65%,`; 
                this.size = 2.5 + Math.random() * 2;
            }

            update() {
                if (!this.arrived) {
                    const dx = this.targetX - this.x;
                    const dy = this.targetY - this.y;
                    const distSq = dx*dx + dy*dy;
                    
                    // Smooth acceleration
                    this.x += dx * 0.18;
                    this.y += dy * 0.18;
                    
                    if (distSq < 25) {
                        this.arrived = true;
                        this.x = this.targetX;
                        this.y = this.targetY;
                        // Add heat to the heat map instead of creating objects
                        addHeat(this.x, this.y, 35 + Math.random() * 20);
                        // Still create a small ripple for visual feedback
                        createRipple(this.x, this.y);
                    }
                } else {
                    this.life -= 0.3; // Fade out quickly after hit
                }
            }

            draw(ctx) {
                if (this.life <= 0) return;
                
                // Glow effect
                ctx.shadowColor = this.color + '0.6)';
                ctx.shadowBlur = 8;
                
                ctx.fillStyle = this.color + this.life + ')';
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.shadowBlur = 0;

                // Trail when flying
                if (!this.arrived) {
                    ctx.strokeStyle = this.color + (this.life * 0.4) + ')';
                    ctx.lineWidth = this.size * 0.6;
                    ctx.lineCap = 'round';
                    ctx.beginPath();
                    ctx.moveTo(this.x, this.y);
                    const prevX = this.x - (this.targetX - this.x) * 0.6; 
                    const prevY = this.y - (this.targetY - this.y) * 0.6;
                    ctx.lineTo(prevX, prevY);
                    ctx.stroke();
                }
            }
        }

        class Ripple {
            constructor(x, y) {
                this.x = x;
                this.y = y;
                this.radius = 3;
                this.maxRadius = 25;
                this.alpha = 0.6;
                this.hue = 200 + Math.random() * 40;
                this.width = 2;
            }
            update() {
                this.radius += (this.maxRadius - this.radius) * 0.15 + 0.8;
                this.alpha -= 0.06;
                this.width -= 0.08;
            }
            draw(ctx) {
                if (this.alpha <= 0) return;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.strokeStyle = `hsla(${this.hue}, 80%, 60%, ${this.alpha})`;
                ctx.lineWidth = Math.max(0.5, this.width);
                ctx.stroke();
            }
        }

        function createRipple(x, y) {
            // Limit ripple count for performance
            if (ripples.length < 30) {
                ripples.push(new Ripple(x, y));
            }
        }

        function animate() {
            pCtx.clearRect(0, 0, els.particleCanvas.width, els.particleCanvas.height);
            
            const cx = els.particleCanvas.width / 2;
            const cy = els.particleCanvas.height / 2;
            
            // Decay and draw heat map (bottom layer)
            decayHeatMap();
            drawHeatMap(pCtx);
            
            // Subtle Sensor Crosshair
            pCtx.strokeStyle = 'rgba(59, 130, 246, 0.2)';
            pCtx.lineWidth = 1;
            pCtx.beginPath(); pCtx.arc(cx, cy, 40, 0, Math.PI*2); pCtx.stroke();
            pCtx.beginPath(); pCtx.arc(cx, cy, 90, 0, Math.PI*2); pCtx.stroke();
            pCtx.beginPath(); pCtx.arc(cx, cy, 140, 0, Math.PI*2); pCtx.stroke();
            
            // Cross lines
            pCtx.strokeStyle = 'rgba(59, 130, 246, 0.25)';
            pCtx.beginPath();
            pCtx.moveTo(cx - 12, cy); pCtx.lineTo(cx + 12, cy);
            pCtx.moveTo(cx, cy - 12); pCtx.lineTo(cx, cy + 12);
            pCtx.stroke();

            // Draw Ripples
            for (let i = ripples.length - 1; i >= 0; i--) {
                ripples[i].update();
                ripples[i].draw(pCtx);
                if (ripples[i].alpha <= 0) ripples.splice(i, 1);
            }

            // Draw Particles (limited count for performance)
            for (let i = particles.length - 1; i >= 0; i--) {
                particles[i].update();
                particles[i].draw(pCtx);
                if (particles[i].life <= 0 && particles[i].arrived) particles.splice(i, 1);
            }

            requestAnimationFrame(animate);
        }
        
        // Initialize heat map and start animation
        setTimeout(() => {
            initHeatMap();
            animate();
        }, 60);

        // --- Logic ---

        function runExperiment() {
            const lambda = state.lambda;
            const count = getPoissonRandom(lambda); 
            
            state.experiments.push(count);
            
            // Update numbers with animation
            const prevCount = els.currentCount.innerText;
            els.currentCount.innerText = count;
            
            // Pop effect
            els.currentCount.style.transform = "scale(1.4)";
            els.currentCount.style.color = "#3b82f6"; // Blue
            setTimeout(() => {
                els.currentCount.style.transform = "scale(1)";
                els.currentCount.style.color = "#1f2937"; // Dark gray
            }, 150);

            updateStats();
            drawChart();

            // Spawn particles
            const cw = els.particleCanvas.width;
            const ch = els.particleCanvas.height;
            
            for (let i = 0; i < count; i++) {
                // Cluster around center
                const r = Math.random() * 80;
                const theta = Math.random() * Math.PI * 2;
                const tx = cw/2 + r * Math.cos(theta);
                const ty = ch/2 + r * Math.sin(theta);
                
                setTimeout(() => {
                    particles.push(new Particle(tx, ty));
                }, Math.random() * 300); // Stagger arrival
            }

            // Subtle Flash if high count
            if (count > lambda * 1.3) {
                els.flashOverlay.style.opacity = 0.25;
                setTimeout(() => els.flashOverlay.style.opacity = 0, 100);
            }
        }

        function calculateSD(data, mean) {
            if (data.length < 2) return 0;
            const variance = data.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / data.length;
            return Math.sqrt(variance);
        }

        function updateStats() {
            const N = state.experiments.length;
            els.totalExperiments.innerText = N;
            els.theoreticalMean.innerText = state.lambda.toFixed(2);
            els.theoreticalSD.innerText = Math.sqrt(state.lambda).toFixed(2);
            
            if (N > 0) {
                const sum = state.experiments.reduce((a, b) => a + b, 0);
                const mean = sum / N;
                els.experimentalMean.innerText = mean.toFixed(2);

                const sd = calculateSD(state.experiments, mean);
                els.experimentalSD.innerText = sd.toFixed(2);

                // Diff Bar Logic
                const diff = mean - state.lambda;
                const maxDiff = 2.0; 
                const percentage = (diff / maxDiff) * 50; 
                
                if (diff >= 0) {
                    els.diffBar.style.left = '50%';
                    els.diffBar.style.width = `${Math.min(percentage, 50)}%`;
                    els.diffBar.classList.remove('bg-orange-500');
                    els.diffBar.classList.add('bg-green-500');
                } else {
                    const w = Math.min(Math.abs(percentage), 50);
                    els.diffBar.style.left = `${50 - w}%`;
                    els.diffBar.style.width = `${w}%`;
                    els.diffBar.classList.remove('bg-green-500');
                    els.diffBar.classList.add('bg-orange-500');
                }
            } else {
                els.experimentalSD.innerText = "0.00";
            }
        }

        function drawChart() {
            const ctx = cCtx;
            const w = els.chartCanvas.width;
            const h = els.chartCanvas.height;
            
            // 1. Clean & Background
            ctx.clearRect(0, 0, w, h);
            
            // Range calculation
            const maxVal = Math.max(Math.max(...state.experiments, 0), state.lambda * 2.2, 12);
            const bins = new Array(Math.floor(maxVal) + 2).fill(0);
            
            state.experiments.forEach(val => {
                if(bins[val] !== undefined) bins[val]++;
            });

            let maxFreq = 0;
            if (state.experiments.length > 0) {
                maxFreq = Math.max(...bins) / state.experiments.length;
            }
            const theoreticalPeak = poissonPMF(Math.floor(state.lambda), state.lambda);
            maxFreq = Math.max(maxFreq, theoreticalPeak);

            const padding = { top: 30, right: 20, bottom: 30, left: 40 };
            const graphW = w - padding.left - padding.right;
            const graphH = h - padding.top - padding.bottom;
            const barWidth = (graphW / bins.length) * 0.65;
            
            // Helper: Coordinate Mapping
            const getX = (k) => padding.left + (k / bins.length) * graphW + (graphW/bins.length)/2;
            const getY = (val) => h - padding.bottom - (val / maxFreq) * graphH;

            // 2. Grid Lines (Subtle & Dashed)
            ctx.strokeStyle = '#e5e7eb'; // Gray 200
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 6]);
            ctx.font = '10px Inter';
            ctx.fillStyle = '#9ca3af';
            ctx.textAlign = 'right';
            ctx.textBaseline = 'middle';

            for(let i=0; i<=4; i++) {
                const val = (i/4) * maxFreq;
                const y = getY(val);
                
                // Line
                ctx.beginPath();
                ctx.moveTo(padding.left, y);
                ctx.lineTo(w - padding.right, y);
                ctx.stroke();
                
                // Y Axis Label
                if (i > 0) ctx.fillText((val * 100).toFixed(0) + '%', padding.left - 8, y);
            }
            ctx.setLineDash([]);

            // 3. Draw SD Range (Soft Gradient Background)
            const sigma = Math.sqrt(state.lambda);
            const m = state.sigmaMultiplier;
            const rangeStart = Math.max(0, state.lambda - m * sigma);
            const rangeEnd = state.lambda + m * sigma;
            
            // Map range to x coordinates
            const xStart = padding.left + (rangeStart / bins.length) * graphW + (graphW/bins.length)/2;
            const xEnd = padding.left + (rangeEnd / bins.length) * graphW + (graphW/bins.length)/2;
            
            if (xEnd > xStart) {
                const gradSD = ctx.createLinearGradient(0, padding.top, 0, h - padding.bottom);
                // Adjust opacity based on multiplier to keep it visible but not overwhelming
                const opacity = m === 1 ? 0.3 : (m === 2 ? 0.2 : 0.15);
                gradSD.addColorStop(0, `rgba(255, 237, 213, ${opacity})`); 
                gradSD.addColorStop(1, `rgba(255, 237, 213, 0.05)`);

                ctx.fillStyle = gradSD;
                ctx.fillRect(xStart, padding.top, xEnd - xStart, graphH);

                // Subtle Bounds
                ctx.strokeStyle = 'rgba(249, 115, 22, 0.3)'; 
                ctx.beginPath();
                ctx.moveTo(xStart, padding.top); ctx.lineTo(xStart, h - padding.bottom);
                ctx.moveTo(xEnd, padding.top); ctx.lineTo(xEnd, h - padding.bottom);
                ctx.stroke();
                
                // Label centered in range
                ctx.fillStyle = '#f97316';
                ctx.font = 'bold 9px Inter';
                ctx.textAlign = 'center';
                const labelText = m === 1 ? 'σ RANGE (68%)' : (m === 2 ? '2σ RANGE (95%)' : '3σ RANGE (99.7%)');
                ctx.fillText(labelText, (xStart + xEnd)/2, padding.top - 8);
            }

            // 4. Draw Bars (Experimental) - Rounded & Gradient
            if (state.experiments.length > 0) {
                bins.forEach((count, k) => {
                    const freq = count / state.experiments.length;
                    if (freq <= 0) return;

                    const x = padding.left + (k / bins.length) * graphW + (graphW/bins.length - barWidth)/2;
                    const yBottom = h - padding.bottom;
                    const yTop = getY(freq);
                    const bH = yBottom - yTop;
                    
                    // Gradient
                    const grad = ctx.createLinearGradient(x, yTop, x, yBottom);
                    grad.addColorStop(0, '#3b82f6'); // Blue 500
                    grad.addColorStop(1, '#dbeafe'); // Blue 100

                    ctx.fillStyle = grad;
                    
                    // Rounded Top Bar
                    ctx.beginPath();
                    const r = Math.min(4, barWidth/2);
                    ctx.moveTo(x, yBottom);
                    ctx.lineTo(x, yTop + r);
                    ctx.quadraticCurveTo(x, yTop, x + r, yTop);
                    ctx.lineTo(x + barWidth - r, yTop);
                    ctx.quadraticCurveTo(x + barWidth, yTop, x + barWidth, yTop + r);
                    ctx.lineTo(x + barWidth, yBottom);
                    ctx.fill();
                });
            }

            // 5. X Axis Labels (Clean)
            ctx.fillStyle = '#6b7280'; // Gray 500
            ctx.font = '10px Inter';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';
            
            bins.forEach((_, k) => {
                // Show labels intelligently to avoid overlap
                const step = bins.length > 20 ? 2 : 1;
                if (k % step === 0) {
                    const x = padding.left + (k / bins.length) * graphW + (graphW/bins.length)/2;
                    ctx.fillText(k, x, h - padding.bottom + 6);
                }
            });

            // 6. Draw Theoretical Curve (Smooth Bezier)
            ctx.strokeStyle = '#f97316'; // Orange 500
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowColor = 'rgba(249, 115, 22, 0.2)';
            ctx.shadowBlur = 4;
            ctx.shadowOffsetY = 2;
            
            ctx.beginPath();
            let first = true;
            
            // Calculate points
            const points = [];
            for(let k=0; k<bins.length; k++) {
                const prob = poissonPMF(k, state.lambda);
                points.push({
                    x: padding.left + (k / bins.length) * graphW + (graphW/bins.length)/2,
                    y: getY(prob)
                });
            }

            // Draw Smooth Curve through points
            if (points.length > 0) {
                ctx.moveTo(points[0].x, points[0].y);
                for (let i = 0; i < points.length - 1; i++) {
                    const p0 = points[i];
                    const p1 = points[i + 1];
                    // Midpoint control logic for simple smoothing
                    const mx = (p0.x + p1.x) / 2;
                    const my = (p0.y + p1.y) / 2;
                    const cp1x = (mx + p0.x) / 2;
                    const cp1y = p0.y; // Bias control point to be horizontal at peaks
                    ctx.quadraticCurveTo(p0.x, p0.y, mx, my); 
                    // Note: A full spline is complex, simple straight lines or quad curves between midpoints work well for visuals
                }
                // Simple Line Connect for precision
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);
                for(let i=1; i<points.length; i++) {
                   ctx.lineTo(points[i].x, points[i].y);
                }
                ctx.stroke();
            }
            
            // Reset Shadow
            ctx.shadowBlur = 0;
            ctx.shadowOffsetY = 0;

            // 7. Theoretical Points (Hollow Circles)
            points.forEach(p => {
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#f97316';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(p.x, p.y, 3.5, 0, Math.PI*2);
                ctx.fill();
                ctx.stroke();
            });
        }

        // --- Interactions ---

        els.lambdaSlider.addEventListener('input', (e) => {
            state.lambda = parseFloat(e.target.value);
            els.lambdaValue.innerText = state.lambda.toFixed(1);
            state.experiments = []; 
            updateStats();
            drawChart();
        });

        els.btnSingle.addEventListener('click', () => {
            runExperiment();
        });

        function toggleAutoRun() {
             if (state.isAutoRunning) {
                state.isAutoRunning = false;
                clearInterval(state.autoRunInterval);
                els.btnAuto.innerHTML = "自动连续实验";
                els.btnAuto.className = "btn-secondary font-semibold py-3 px-4 rounded-xl transition-all active:scale-95";
            } else {
                state.isAutoRunning = true;
                els.btnAuto.innerHTML = `
                    <span class="flex items-center justify-center gap-2">
                        <span class="w-2 h-2 bg-red-500 rounded-full animate-pulse"></span>
                        停止实验
                    </span>`;
                els.btnAuto.className = "bg-red-50 text-red-600 border border-red-200 font-semibold py-3 px-4 rounded-xl transition-all hover:bg-red-100";
                
                state.autoRunInterval = setInterval(() => {
                    runExperiment();
                }, state.simulationSpeed);
            }
        }

        els.btnAuto.addEventListener('click', toggleAutoRun);

        els.btnReset.addEventListener('click', () => {
            state.experiments = [];
            updateStats();
            drawChart();
            particles = [];
            ripples = [];
            clearHeatMap(); // Clear the heat map
            els.currentCount.innerText = "-";
            els.experimentalMean.innerText = "0.00";
            els.experimentalSD.innerText = "0.00";
            els.diffBar.style.width = "0px";
            pCtx.clearRect(0, 0, els.particleCanvas.width, els.particleCanvas.height);
        });

        // --- Speed Controls ---

        function setSpeed(speedMs, activeBtnId) {
            state.simulationSpeed = speedMs;
            [els.speedSlow, els.speedNormal, els.speedFast].forEach(btn => {
                btn.className = "flex-1 py-1 text-xs font-bold rounded text-gray-500 hover:bg-gray-100 transition-colors";
            });
            const activeBtn = document.getElementById(activeBtnId);
            activeBtn.className = "flex-1 py-1 text-xs font-bold rounded bg-blue-100 text-blue-700 shadow-sm";
            
            if (state.isAutoRunning) {
                clearInterval(state.autoRunInterval);
                state.autoRunInterval = setInterval(runExperiment, state.simulationSpeed);
            }
        }

        els.speedSlow.addEventListener('click', () => setSpeed(800, 'speedSlow'));
        els.speedNormal.addEventListener('click', () => setSpeed(100, 'speedNormal'));
        els.speedFast.addEventListener('click', () => setSpeed(20, 'speedFast'));

        function setSigma(val, btnId) {
            state.sigmaMultiplier = val;
            drawChart();
            
            // Reset styles
            [els.btnSigma1, els.btnSigma2, els.btnSigma3].forEach(btn => {
                btn.className = "px-2 py-0.5 text-[10px] font-bold rounded-md text-gray-400 hover:text-gray-600 transition-all";
            });
            
            // Active style
            const activeBtn = document.getElementById(btnId);
            activeBtn.className = "px-2 py-0.5 text-[10px] font-bold rounded-md bg-white shadow-sm text-blue-600 transition-all";
            
            // Update legend text
            const text = val === 1 ? "1σ 区间" : (val === 2 ? "2σ 区间" : "3σ 区间");
            els.legendSigmaText.innerText = text;
        }

        els.btnSigma1.addEventListener('click', () => setSigma(1, 'btnSigma1'));
        els.btnSigma2.addEventListener('click', () => setSigma(2, 'btnSigma2'));
        els.btnSigma3.addEventListener('click', () => setSigma(3, 'btnSigma3'));

    </script>
</body>
</html>

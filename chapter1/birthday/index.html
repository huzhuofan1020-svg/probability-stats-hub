<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>古典概型：生日问题互动演示</title>
    <!-- 引入 Chart.js -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --primary-color: #8cc63f; /* 原图顶部那种清新的绿色 */
            --primary-dark: #669c28;
            --accent-purple: #9b59b6;
            --accent-red: #e74c3c;
            --bg-color: #f4f7f6;
            --card-shadow: 0 4px 15px rgba(0,0,0,0.05);
        }

        body { font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; background-color: var(--bg-color); color: #333; margin: 0; padding: 20px; line-height: 1.6; }

        .container { max-width: 1200px; margin: 0 auto; }

        /* 标题栏 */
        header { text-align: center; margin-bottom: 30px; padding: 20px; background: white; border-top: 5px solid var(--primary-color); border-radius: 8px; box-shadow: var(--card-shadow); }
        h1 { margin: 0; color: #333; font-weight: 300; letter-spacing: 1px; }
        .subtitle { font-size: 0.9em; color: #888; margin-top: 5px; text-transform: uppercase; }
        .highlight-box { background: var(--primary-color); color: white; display: inline-block; padding: 2px 10px; border-radius: 4px; font-weight: bold; transform: rotate(-2deg); margin-left: 10px; }

        /* 通用卡片 */
        .card { background: white; border-radius: 12px; padding: 20px; margin-bottom: 20px; box-shadow: var(--card-shadow); border: 1px solid #eee; }
        .card-title { font-size: 1.1em; color: var(--primary-dark); border-left: 4px solid var(--primary-color); padding-left: 12px; margin-bottom: 15px; font-weight: bold; display: flex; justify-content: space-between; align-items: center; }

        /* 控制面板 */
        .control-bar { display: flex; justify-content: space-between; align-items: center; background: #eef7e6; padding: 15px 25px; border-radius: 8px; margin-bottom: 20px; flex-wrap: wrap; gap: 10px; }
        .btn-main { background-color: var(--primary-color); color: white; border: none; padding: 10px 25px; border-radius: 25px; font-size: 16px; cursor: pointer; transition: 0.2s; font-weight: bold; box-shadow: 0 4px 6px rgba(140, 198, 63, 0.3); }
        .btn-main:hover { background-color: var(--primary-dark); transform: translateY(-2px); }
        .stat-item { text-align: center; }
        .stat-val { font-size: 1.5em; font-weight: bold; color: var(--primary-dark); }
        .stat-label { font-size: 0.8em; color: #666; }

        /* === 布局核心：Flexbox 替代 Grid 以防遮挡 === */
        .layout-flex {
            display: flex;
            flex-wrap: wrap; /* 关键：允许换行 */
            gap: 20px;
        }

        /* 左侧大图容器 */
        .left-panel {
            flex: 1 1 400px; /* 基础宽度400，允许伸缩 */
            min-width: 300px;
            display: flex;
            flex-direction: column;
        }

        /* 右侧两图容器 */
        .right-panel {
            flex: 1 1 400px; /* 基础宽度400，允许伸缩 */
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* 图表专用盒子，确保高度固定 */
        .chart-wrapper { position: relative; width: 100%; overflow: hidden; background: #fff; }
        .tall-chart { height: 520px; } /* 左侧高图 */
        .short-chart { height: 250px; } /* 右侧矮图 */

        canvas { display: block; width: 100%; height: 100%; }

        /* 表格样式优化 */
        .data-table-wrapper { overflow-x: auto; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 0.9em; }
        th { background-color: #f8f8f8; color: #555; padding: 12px; font-weight: 600; text-align: center; border-bottom: 2px solid var(--primary-color); }
        td { padding: 10px; text-align: center; border-bottom: 1px solid #eee; color: #555; }
        tr:last-child { background-color: #fafafa; font-weight: bold; }
        tr:hover { background-color: #f0f8ff; }

    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>数学实验：<span class="highlight-box">生日悖论</span></h1>
        <div class="subtitle">Classic Probability Model Simulation</div>
    </header>

    <!-- 模拟演示区 -->
    <section class="card">
        <div class="card-title">
            计算机模拟实验 (Simulations)
            <small style="font-weight: normal; font-size: 0.8em; color:#999;">n=30人/班, 模拟100次</small>
        </div>
        
        <div class="control-bar">
            <div class="stat-item">
                <div class="stat-label">试验总次数</div>
                <div id="disp-trials" class="stat-val">0</div>
            </div>
            <button class="btn-main" onclick="startSimulation()">▶ 开始模拟 (Run)</button>
            <div class="stat-item">
                <div class="stat-label">发现相同生日频率</div>
                <div id="disp-freq" class="stat-val" style="color: var(--accent-red)">0%</div>
            </div>
        </div>

        <!-- 布局容器：Flex布局，防止遮挡 -->
        <div class="layout-flex">
            
            <!-- 左侧：全景图 -->
            <div class="left-panel">
                <div class="chart-wrapper tall-chart" style="border: 1px solid #ddd; border-radius: 8px;">
                    <!-- 自定义Canvas绘制 -->
                    <canvas id="matrixCanvas"></canvas>
                </div>
                <p style="text-align: center; color: #888; font-size: 0.8em; margin-top: 8px;">
                    ▲ 模拟全景图：每一竖列代表一个班级，红点代表生日相同
                </p>
            </div>

            <!-- 右侧：分图 -->
            <div class="right-panel">
                
                <!-- 右上：单次展示 -->
                <div class="chart-wrapper short-chart" style="border: 1px solid #ddd; border-radius: 8px; position: relative;">
                    <div style="position: absolute; top:10px; left:10px; font-size:0.8em; color:#999; z-index:10;">最近一次试验可视化:</div>
                    <canvas id="singleVizCanvas"></canvas>
                </div>
                <p style="text-align: center; color: #888; font-size: 0.8em; margin: -10px 0 0 0;">
                    ▲ 连线表示两人生日撞车 (紫线连接)
                </p>

                <!-- 右下：收敛曲线 -->
                <div class="chart-wrapper short-chart">
                    <canvas id="chartJSConvergence"></canvas>
                </div>
            </div>

        </div>
    </section>

    <!-- 真实数据区 -->
    <section class="card">
        <div class="card-title">真实数据验证 (2005-2012级本科生)</div>
        <div class="layout-flex">
            <!-- 左侧图表 -->
            <div style="flex: 2; min-width: 300px; height: 350px;">
                <canvas id="realDataChart"></canvas>
            </div>
            <!-- 右侧表格 -->
            <div style="flex: 1; min-width: 280px; max-height: 350px; overflow-y: auto;" class="data-table-wrapper">
                <table>
                    <thead>
                        <tr><th>年份</th><th>总班数</th><th>撞车班数</th><th>比例</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>2005</td><td>114</td><td>75</td><td>65.8%</td></tr>
                        <tr><td>2006</td><td>112</td><td>79</td><td>70.5%</td></tr>
                        <tr><td>2007</td><td>111</td><td>83</td><td>74.8%</td></tr>
                        <tr><td>2008</td><td>112</td><td>88</td><td>78.6%</td></tr>
                        <tr><td>2009</td><td>121</td><td>83</td><td>68.6%</td></tr>
                        <tr><td>2010</td><td>119</td><td>77</td><td>64.7%</td></tr>
                        <tr><td>2011</td><td>120</td><td>87</td><td>72.5%</td></tr>
                        <tr><td>2012</td><td>121</td><td>82</td><td>67.8%</td></tr>
                        <tr><td>合计</td><td>930</td><td>654</td><td style="color:var(--accent-red)">70.32%</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
        <div style="margin-top:15px; background: #fffbe6; padding: 10px; border-left: 4px solid orange; color: #666; font-size: 0.9em;">
            <strong>教学总结：</strong> 真实数据的 70.32% 与理论计算值 70.6% 极其接近。通过 930 个班级的大样本统计，有力地验证了概率模型的正确性。
        </div>
    </section>
</div>

<script>
    /* =========================================
       全局变量与初始化
    ========================================= */
    const N_CLASS_SIZE = 30;  // 班级人数
    const MAX_TRIALS = 100;   // 每次演示模拟次数
    let currentTrial = 0;
    let matchesCount = 0;
    let isRunning = false;
    let animationFrameId;

    // 获取 DOM
    const canvasM = document.getElementById('matrixCanvas');
    const ctxM = canvasM.getContext('2d');
    const canvasS = document.getElementById('singleVizCanvas');
    const ctxS = canvasS.getContext('2d');

    // Chart.js 实例 (收敛图)
    let convChart = null;
    
    // 初始化收敛图
    function initConvChart() {
        const ctx = document.getElementById('chartJSConvergence').getContext('2d');
        convChart = new Chart(ctx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [{
                    label: '模拟频率',
                    data: [],
                    borderColor: '#3498db',
                    borderWidth: 2,
                    pointRadius: 0,
                    tension: 0.1
                }, {
                    label: '理论值 (70.6%)',
                    data: [],
                    borderColor: '#e74c3c',
                    borderWidth: 2,
                    borderDash: [5, 5],
                    pointRadius: 0
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                plugins: { legend: { display: true, position: 'top' }, title: {display: true, text: '频率收敛趋势'} },
                scales: { y: { min: 0, max: 100, title:{display:true, text:'概率%'}}, x: { display:false } }
            }
        });
    }

    /* =========================================
       绘图辅助函数
    ========================================= */
    
    // 调整Canvas清晰度
    function resizeCanvas(canvas) {
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.parentElement.getBoundingClientRect();
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        const ctx = canvas.getContext('2d');
        ctx.scale(dpr, dpr);
        return { w: rect.width, h: rect.height };
    }

    // 绘制矩阵中的一列（对应左侧图）
    function drawMatrixColumn(trialIndex, width, height, data, duplicates) {
        const colW = width / MAX_TRIALS;
        const rowH = height / N_CLASS_SIZE;
        const x = trialIndex * colW;

        // 绘制该次试验的竖条背景 (偶数次稍微深一点，方便区分)
        if(trialIndex % 2 === 0) {
            ctxM.fillStyle = 'rgba(0,0,0,0.02)';
            ctxM.fillRect(x, 0, colW, height);
        }

        // 绘制点
        data.forEach((day, idx) => {
            const y = idx * rowH + rowH/2;
            const cx = x + colW/2;
            
            // 判断是否是重复生日
            const isMatch = duplicates.includes(day);

            ctxM.beginPath();
            if (isMatch) {
                ctxM.fillStyle = '#e74c3c'; // 红点
                ctxM.arc(cx, y, Math.min(colW, rowH)/2.5, 0, Math.PI*2);
            } else {
                ctxM.fillStyle = '#bdc3c7'; // 灰点
                ctxM.arc(cx, y, Math.min(colW, rowH)/4, 0, Math.PI*2); // 稍微小一点
            }
            ctxM.fill();
        });
    }

    // 绘制单次试验可视化（对应右上图：连线）
    function drawSingleVisualization(width, height, data, duplicates) {
        ctxS.clearRect(0,0, width, height); // 清空
        
        // 绘制坐标系背景
        ctxS.strokeStyle = '#eee';
        ctxS.beginPath();
        ctxS.moveTo(20, height - 20); ctxS.lineTo(width-20, height - 20); // x轴
        ctxS.moveTo(20, 20); ctxS.lineTo(20, height - 20); // y轴
        ctxS.stroke();

        // 计算坐标
        const paddingX = 40;
        const paddingY = 40;
        const effW = width - paddingX * 2;
        const effH = height - paddingY * 2;
        
        const points = data.map((d, i) => ({
            x: paddingX + (i / (N_CLASS_SIZE-1)) * effW,
            y: (height - paddingY) - (d/365) * effH,
            day: d
        }));

        // 绘制连线 (Purple Lines)
        // 只连接重复的
        const groups = {};
        duplicates.forEach(d => groups[d] = []); // init
        points.forEach(p => {
            if(duplicates.includes(p.day)) {
                if(!groups[p.day]) groups[p.day] = [];
                groups[p.day].push(p);
            }
        });

        ctxS.lineWidth = 2;
        ctxS.strokeStyle = 'rgba(155, 89, 182, 0.6)'; // 紫色半透明

        for(let day in groups) {
            const grp = groups[day];
            if(grp.length > 1) {
                ctxS.beginPath();
                ctxS.moveTo(grp[0].x, grp[0].y);
                for(let k=1; k<grp.length; k++) {
                    ctxS.lineTo(grp[k].x, grp[k].y);
                }
                ctxS.stroke();
            }
        }

        // 绘制点
        points.forEach(p => {
            ctxS.beginPath();
            if(duplicates.includes(p.day)) {
                ctxS.fillStyle = '#e74c3c'; // Match Red
                ctxS.arc(p.x, p.y, 4, 0, Math.PI*2);
                ctxS.fill();
                // 绘制一个小光晕
                ctxS.strokeStyle = 'rgba(231, 76, 60, 0.3)';
                ctxS.beginPath();
                ctxS.arc(p.x, p.y, 8, 0, Math.PI*2);
                ctxS.stroke();
            } else {
                ctxS.fillStyle = '#3498db'; // Normal Blue
                ctxS.arc(p.x, p.y, 2.5, 0, Math.PI*2);
                ctxS.fill();
            }
        });
    }

    /* =========================================
       主逻辑
    ========================================= */
    function startSimulation() {
        if(isRunning) return; // 防止重复点击
        isRunning = true;
        
        // 重置数据
        currentTrial = 0;
        matchesCount = 0;
        convChart.data.labels = [];
        convChart.data.datasets[0].data = [];
        convChart.data.datasets[1].data = [];
        
        // 重置 Canvas 尺寸
        const dimM = resizeCanvas(canvasM);
        const dimS = resizeCanvas(canvasS);

        // 清空矩阵
        ctxM.clearRect(0,0, dimM.w, dimM.h);

        function step() {
            if(currentTrial >= MAX_TRIALS) {
                isRunning = false;
                return;
            }

            // 1. 生成数据
            const data = Array.from({length: N_CLASS_SIZE}, () => Math.floor(Math.random() * 365) + 1);
            
            // 2. 检查重复
            const counts = {};
            const duplicates = [];
            let hasMatch = false;
            data.forEach(x => { counts[x] = (counts[x] || 0) + 1; });
            for(let k in counts) {
                if(counts[k] > 1) {
                    hasMatch = true;
                    duplicates.push(parseInt(k));
                }
            }

            if(hasMatch) matchesCount++;
            currentTrial++;

            // 3. 更新 UI 文字
            document.getElementById('disp-trials').innerText = currentTrial;
            const freq = (matchesCount / currentTrial * 100).toFixed(1);
            document.getElementById('disp-freq').innerText = freq + "%";

            // 4. 绘图 - 矩阵图
            drawMatrixColumn(currentTrial - 1, dimM.w, dimM.h, data, duplicates);

            // 5. 绘图 - 单次可视图 (为了性能和视觉，每帧都画，或者跳帧)
            drawSingleVisualization(dimS.w, dimS.h, data, duplicates);

            // 6. 绘图 - 收敛图 ChartJS
            convChart.data.labels.push(currentTrial);
            convChart.data.datasets[0].data.push(freq);
            convChart.data.datasets[1].data.push(70.6);
            
            // 每5帧刷新一次ChartJS，防止卡顿
            if(currentTrial % 5 === 0 || currentTrial === MAX_TRIALS) {
                convChart.update('none'); 
            }

            animationFrameId = requestAnimationFrame(step);
        }

        step();
    }

    /* =========================================
       真实数据图表 (Combo Chart)
    ========================================= */
    function renderRealDataChart() {
        const ctx = document.getElementById('realDataChart').getContext('2d');
        new Chart(ctx, {
            type: 'bar',
            data: {
                labels: ['2005', '2006', '2007', '2008', '2009', '2010', '2011', '2012'],
                datasets: [
                    {
                        label: '自然班数',
                        data: [114, 112, 111, 112, 121, 119, 120, 121],
                        backgroundColor: '#d5e8d4',
                        order: 2,
                        yAxisID: 'y'
                    },
                    {
                        label: '相同生日班数',
                        data: [75, 79, 83, 88, 83, 77, 87, 82],
                        backgroundColor: '#82b366',
                        order: 3,
                        yAxisID: 'y'
                    },
                    {
                        type: 'line',
                        label: '撞车比例 (%)',
                        data: [65.79, 70.54, 74.77, 78.57, 68.60, 64.71, 72.50, 67.77],
                        borderColor: '#c00000',
                        borderWidth: 2,
                        tension: 0.3,
                        pointBackgroundColor: 'white',
                        pointBorderColor: '#c00000',
                        pointRadius: 4,
                        order: 1,
                        yAxisID: 'y1'
                    }
                ]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    tooltip: { mode: 'index', intersect: false }
                },
                scales: {
                    y: { 
                        position: 'left',
                        title: { display: true, text: '班级数' }
                    },
                    y1: { 
                        position: 'right', 
                        min: 50, 
                        max: 100, 
                        grid: { drawOnChartArea: false },
                        title: { display: true, text: '比例 (%)' }
                    }
                }
            }
        });
    }

    // 初始化
    window.onload = function() {
        initConvChart();
        renderRealDataChart();
        // 自动调整Canvas大小一次，避免初始模糊
        resizeCanvas(canvasM);
        resizeCanvas(canvasS);
    };

    // 监听窗口调整，重绘空白画布以适应
    window.onresize = function() {
         if(!isRunning) {
            resizeCanvas(canvasM);
            resizeCanvas(canvasS);
         }
    };

</script>
</body>
</html>
